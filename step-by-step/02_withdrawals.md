# Withdrawals

Now that we covered deposits, let's look at withdrawals.

We want to withdraw some ETH from our rich account on L2, to some account on L1.

We can keep using the example address from 01_deposits:

```shell
export DESTINATION_ADDRESS=0xF3F011F9Ab6252F9Aad3A472E47D365E85e33437
```

and let's double-check that it has 0 balance on L1.

```shell
cast balance $DESTINATION_ADDRESS
# response should be 0
```

Our withdrawal process will consist of 2 steps:
* burning assets on L2, which will generate an event
* finalizing the withdrawal on L1, by showing the proof of this even to the L1 contract, which will then transfer the funds to our account.


## Withdrawing base token

To withdraw base token, you only have to call the special address (l2 base token) with `withdraw(address)` method, and pass necessary value.

```shell
export L2_BASE_TOKEN=0x000000000000000000000000000000000000800a
```


```shell
cast send -r http://localhost:3050 $L2_BASE_TOKEN "withdraw(address)" $DESTINATION_ADDRESS --value 100 --private-key $PRIVATE_KEY
```

Great, now we have to remember the transaction id and "claim" these tokens on L1.

## Claiming tokens (a.k.a withdrawal finalizer)

The final step, is to claim the tokens on L1. When we did the deposit (from L1 to L2), L2 "claim" part was done automatically.

In the opposite direction, it has to be done manually.
In real use cases, this is handled by tools like SDK and Portal, but in this tutorial, let's do it "manually".

Bridgehub on L1, is storing all the information about the state of L2 (including things like event tree root hashes etc). What we have to do now, is to present it with a proof of the event, that we really requested that asset withdrawal.

This part is permisionless, so anyone can "finalize" the withdrawal for anyone else.


### Getting proof

Each batch that is posted to L1, contains all events, and a root of a merkle tree. We have to build a "merkle proof" out of that.

Here, we'll actually call the RPC to get it, but in the future we should write a tool to compute it on our own.

The first parameter is the transaction hash (the transaction that you sent above to withdraw funds), and the second parameter is the "index" - in case you did multiple withdrawals within a single transaction. We did only one withdrawal, so the index is 0.

```shell
curl --request POST \
  --url http://localhost:3050 \
  --header 'Content-Type: application/json' \
  --data '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "zks_getL2ToL1LogProof",
      "params": [
        "0x2a97bd46273f33d66bfa25b2f19a9e442b6eb9db3b079cdc12ee64630944b46c",
        0
      ]
    }'
```

This will return a bunch of data,  including a proof.
You might want to pipe it to something like `| jq ".result.proof"' for easier reading.

Proof will look something like this:

```shell
[
  "0x010f000100000000000000000000000000000000000000000000000000000000",
  "0x72abee45b59e344af8a6e520241c4744aff26ed411f4c4b00f8af09adada43ba",

  ...
  
  "0xfef7bd9f889811e59e4076a0174087135f080177302763019adaf531257e3a87",
  "0xf6e093070e0389d2e529d60fadb855fdded54976ec50ac709e3a36ceaa64c291",
  "0x0000000000000000000000000000000000000000000000000000000000000000"
]
```

### Getting withdrawal message

We also need to get a withdrawal message. There are two possibilities:
* we could reconstruct it from scratch
* or we could take it from the event.

If you look on the logs/events from your L2 transaction, you'll see:


```json
logs                 [{"address":"0x0000000000000000000000000000000000008008","topics":["0x3a36e47291f4201faf137fab081d92295bce2d53be2c6ca68ba82c7faa9ce241","0x000000000000000000000000000000000000000000000000000000000000800a","0x415a3220d01928b10a88fad06622835911dc56c9a214357d10bf5f31857c3c71"],"data":"0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000386c0960f9f3f011f9ab6252f9aad3a472e47d365e85e3343700000000000000000000000000000000000000000000000000000000000000640000000000000000",
```

This is an event generated by `0x8008` (a.k.a L1Messenger), and data contains the payload.
This payload is abi-wrapped, so we have to get rid of wrapping:

```shell
cast abi-decode 'x()(bytes)' 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000386c0960f9f3f011f9ab6252f9aad3a472e47d365e85e3343700000000000000000000000000000000000000000000000000000000000000640000000000000000
# result will be
# 0x6c0960f9f3f011f9ab6252f9aad3a472e47d365e85e334370000000000000000000000000000000000000000000000000000000000000064

export MESSAGE=0x6c0960f9f3f011f9ab6252f9aad3a472e47d365e85e334370000000000000000000000000000000000000000000000000000000000000064
```


### Finalizing withdrawal

Now we can finalize withdrawal on L1. First we need to get address of the L1Nullifier.:

```shell
cast call $BRIDGEHUB_ADDRESS "assetRouter()(address)"
# result: 0x69B93ACEA375D2a951a5Dea89C9Bfc6A3EbDe36e
export L1_ASSET_ROUTER=0x69B93ACEA375D2a951a5Dea89C9Bfc6A3EbDe36e
```

Then call asset router to get nullifier

```shell
cast call $L1_ASSET_ROUTER "L1_NULLIFIER()(address)"
# result 0xdd56263da226E61D5e015D82631FA2d5cD9CBc40
export L1_NULLIFIER=0xdd56263da226E61D5e015D82631FA2d5cD9CBc40
```

And now we can call `finalizeWithdrawal` method:

```
struct FinalizeL1DepositParams {
    uint256 chainId;          # L2 chain id - usually 270
    uint256 l2BatchNumber;    # returned in getL2toL1Log proof rpc above
    uint256 l2MessageIndex;   # 0 - as we had only 1 withdrawal
    address l2Sender;         # This will be the base token contract (0x800a)
    uint16 l2TxNumberInBatch; # 0 - 
    bytes message;            # message - see below
    bytes32[] merkleProof;    # merkle proof - see above
}
```

Let's try 'call' first:
```shell
cast call  $L1_NULLIFIER "finalizeDeposit((uint256,uint256,uint256,address,uint16,bytes,bytes32[]))" "(270,4,0,$L2_BASE_TOKEN,0,$MESSAGE,$MERKLE_PROOF)"
```

ok, it worked, so now let's do send:

```shell
cast send  $L1_NULLIFIER "finalizeDeposit((uint256,uint256,uint256,address,uint16,bytes,bytes32[]))" "(270,4,0,$L2_BASE_TOKEN,0,$MESSAGE,$MERKLE_PROOF)" --private-key $PRIVATE_KEY
```

And we can check that user got funds on L1:

```shell
cast balance $DESTINATION_ADDRESS
# should show 100.
```

Congratulations, you managed to withdraw ETH from L2 to L1.

In the followup articles, we'll look into depositing and withdrawing custom ERC tokens. The general approach will be similar, but we'll have to pass additional data.